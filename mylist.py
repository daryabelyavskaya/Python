# -*- coding: utf-8 -*-
"""Copy of ListTask.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TC4JwYetvb2TEaPP_sOW6KT0j3IwsZcS

# MyAwesomeList

Вам нужно реализовать класс-наследник стандартного списка, в котором добавить аттрибуты(property):
* **reversed** (с коротким псевдонимом **R**):
  * При обращении возвращается список с элементами в обратном порядке.
* **first** (с коротким псевдонимом **F**):
  * При обращении возвращается первый элемент списка. 
  * Должна присутствовать возможность изменять этот атрибут. Вместе с ним должен меняться и сам список
  * При попытке прочитать или установить значение **first** в пустом списке бросается исключение
* **last** (с коротким псевдонимом **L**):
  * При обращении возвращается последний элемент списка.
  * Должна присутствовать возможность изменять этот атрибут. Вместе с ним должен меняться и сам список. 
  * При попытке прочитать или установить значение **last** в пустом списке бросается исключение
* **size** (с коротким псевдонимом **S**):
  * При обращении возвращается размер списка. 
  * Должна присутствовать возможность изменять этот атрибут: 
    при увеличении размера в конец должны добавляться значения None, 
    а при уменьшении последние элементы должны удаляться.


"""
class ListTwist(list):

    def __init__(self, list):
        self._list = list

    def __str__(self):
        return str(self._list)

    @property
    def R(self):
        return reversed(self)

    def reversed(self):
        copy = self._list.copy()
        copy.reverse()
        return copy

    @property
    def F(self):
        return self.first

    @F.setter
    def F(self, x):
        self.first = x


@property
def first(self):
    if len(self._list) == 0:
        raise ValueError("List is empty!")
    return self._list[0]


@first.setter
def first(self, x):
    if len(self._list) == 0:
        raise ValueError("List is empty!")
    self._list[0] = x


@property
def L(self):
    return self.last


@L.setter
def L(self, x):
    self.last = x


@property
def last(self):
    if len(self._list) == 0:
        raise ValueError("List is empty!")
    return self._list[len(self._list) - 1]


@last.setter
def last(self, x):
    if len(self._list) == 0:
        raise ValueError("List is empty!")
    self._list[len(self._list) - 1] = x


@property
def S(self):
    return size(self)

@property
def size(self):
    return len(self._list)


@size.setter
def size(self, x):
    if len(self._list) >= x:
        del self._list[x:len(self._list)]
    else:
        for i in range(len(self._list), x, 1):
            self._list.append(None)
